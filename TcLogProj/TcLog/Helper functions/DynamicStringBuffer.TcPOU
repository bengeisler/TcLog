<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.11">
  <POU Name="DynamicStringBuffer" Id="{660876ea-7fc3-4366-aa3c-17474f122e75}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK DynamicStringBuffer
VAR_INPUT
END_VAR
VAR_OUTPUT
	Error						:	ST_ERROR;								// Error information of this FB
END_VAR
VAR
	Fifo						:	FB_StringRingBuffer;					// Necessary to buffer log data until it has been written to file.
	MemMan						:	FB_DynMem_Manager;						// Memory manager, required by DynMem_Buffer.
	MemBuf						:	FB_DynMem_Buffer(ipMemMan := MemMan);	// Provides dynamic buffer for Fifo. Is extended automatically if more than the 
																			// default buffer size is needed.
	{attribute 'hide'} 														
	_busy						: 	BOOL;									// Buffer is busy; typically with writing data to the file system.
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[]]></ST>
    </Implementation>
    <Method Name="AddLine" Id="{40352fe7-a10a-404f-8748-bb98576a3241}">
      <Declaration><![CDATA[METHOD AddLine : BOOL
VAR_INPUT
	Text	:	T_MAXSTRING;	//	Text to be added to the buffer
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[ResizeFifoBufferIfNecessary();
Fifo.A_AddTail(putValue := CONCAT(Text, '$N')); ]]></ST>
      </Implementation>
    </Method>
    <Method Name="AddString" Id="{6405c45a-0cb8-4431-a2bb-9cf39dc1e728}">
      <Declaration><![CDATA[METHOD AddString : BOOL
VAR_INPUT
	Text	:	T_MAXSTRING;	// 	String to be added to the buffer
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[ResizeFifoBufferIfNecessary();
Fifo.A_AddTail(putValue := Text); ]]></ST>
      </Implementation>
    </Method>
    <Method Name="AllocateBuffer" Id="{bc70064d-9855-4df2-8293-04935db0d914}">
      <Declaration><![CDATA[METHOD PRIVATE AllocateBuffer : BOOL	// Allocates buffer for the Fifo.
VAR_INPUT
	nbufferSize : UDINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[MemBuf.CreateBuffer(nSize:=nbufferSize*SIZEOF(BYTE), bReset:=TRUE);
Fifo.pBuffer := MemBuf.pBuffer;
Fifo.cbBuffer := nbufferSize*SIZEOF(BYTE);]]></ST>
      </Implementation>
    </Method>
    <Property Name="Busy" Id="{b23806d3-8c54-456d-b666-1c83eaca7b17}">
      <Declaration><![CDATA[{attribute 'monitoring':='call'}
PROPERTY Busy : BOOL]]></Declaration>
      <Get Name="Get" Id="{79b6117a-b0f4-49c4-8f2f-309ee42a8d23}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[Busy := _busy;]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{6b0f6f5d-2bb7-48c7-aa0b-845c65d65996}">
        <Declaration><![CDATA[PRIVATE
VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[_busy := Busy;]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Method Name="FB_exit" Id="{410b66b7-6428-4a64-9cb8-9b83e356f18f}">
      <Declaration><![CDATA[METHOD FB_exit : BOOL
VAR_INPUT
	bInCopyCode : BOOL; // if TRUE, the exit method is called for exiting an instance that is copied afterwards (online change).
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[MemBuf.Clear();]]></ST>
      </Implementation>
    </Method>
    <Method Name="FlushCache" Id="{fa7baa03-4401-42cd-8818-9657ae6b0935}">
      <Declaration><![CDATA[METHOD FlushCache : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[Fifo.A_Reset();]]></ST>
      </Implementation>
    </Method>
    <Method Name="Init" Id="{537021d7-4637-4ad9-9438-a76ff90a964b}">
      <Declaration><![CDATA[METHOD INTERNAL Init : BOOL
VAR_INPUT
	nBufferSize : UDINT; // Buffer size for the string buffer
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[AllocateBuffer(nBufferSize);]]></ST>
      </Implementation>
    </Method>
    <Method Name="PersistToFile" Id="{9df1c79b-f420-4db7-a528-f4f3a2facd9b}">
      <Declaration><![CDATA[METHOD PersistToFile : BOOL
VAR_INPUT
	FileName			:	T_MAXSTRING;			//	File name including its path
END_VAR
VAR_INST
	state				:	UINT;		
		
	fbFileOpen      	: 	FB_FileOpen;
	hFile          		: 	UINT;
	               	
	fbFileWrite			:	FB_FileWrite;
	lockFileWriteToForceRisingEdge	:	BOOL;			// filePuts can only be executed every other cycle
											// since it needs a rising edge to execute.
	               	
	fbFileClose    	 	: 	FB_FileClose;
	
	buffer				:	ARRAY[0..CONSTANTS.BUFFER_SIZE] OF BYTE;
	currentBufferPos	:	UDINT;
	fifoHeadString		: 	T_MAXSTRING;
	fifoHeadLength		: 	UDINT;
	fifoHeadBytes		:	ARRAY[0..MAX_STRING_LENGTH] OF BYTE;
	i					:	UINT;
END_VAR
VAR CONSTANT

	STATE_IDLE							:	UINT	:=	0;
	STATE_OPEN_FILE						:	UINT	:= 	1;
	STATE_GET_STRING_FROM_FIFO		 	:	UINT 	:= 	2;
	STATE_APPEND_DATA_TO_FILE			:	UINT	:= 	3;
	STATE_CLOSE_FILE					:	UINT	:=	4;
	
	NET_ID 				: 	STRING := '';
	TIMEOUT 			: 	TIME := DEFAULT_ADS_TIMEOUT;
	
	MAX_LOGS_PER_CYCLE 	:	UINT := DINT_TO_UINT(CONSTANTS.BUFFER_SIZE / UDINT_TO_DINT(MAX_STRING_LENGTH));
	MAX_BUFFER_POS		:	UDINT := (SIZEOF(buffer) - MAX_STRING_LENGTH);
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// State machine
// Using if-statements instead of case for performance reasons:
// Some states execute instantly and allow thus the next state 
// to start within the same plc cycle.

// *** I D L E ***
IF state = STATE_IDLE THEN
	lockFileWriteToForceRisingEdge := FALSE;
	IF Fifo.nCount > 0 THEN 
		lockFileWriteToForceRisingEdge := FALSE;
		state := STATE_OPEN_FILE;
	END_IF
END_IF
		
// *** O P E N   F I L E ***
fbFileOpen(
	sNetId := NET_ID, sPathName := FileName, nMode := FOPEN_MODEAPPEND OR FOPEN_MODETEXT, 
	ePath := PATH_GENERIC, bExecute := (state = STATE_OPEN_FILE), tTimeout := TIMEOUT,
	hFile => hFile);

IF state = STATE_OPEN_FILE THEN
	IF fbFileOpen.bError THEN
		state := STATE_CLOSE_FILE;
	ELSIF NOT fbFileOpen.bBusy THEN 
		state := STATE_GET_STRING_FROM_FIFO; 
	END_IF
END_IF 

// *** P O P   F R O M   F I F O ***
IF state = STATE_GET_STRING_FROM_FIFO THEN
	IF NOT lockFileWriteToForceRisingEdge THEN
		currentBufferPos := 0;
		FOR i:=0 TO MAX_LOGS_PER_CYCLE DO
			IF Fifo.nCount <= 0 THEN EXIT; END_IF
			IF currentBufferPos >= MAX_BUFFER_POS THEN EXIT; END_IF
			
			Fifo.A_RemoveHead(getValue => fifoHeadString);	
			fifoHeadBytes := MAXSTRING_TO_BYTEARR(fifoHeadString);
			fifoHeadLength := INT_TO_UDINT(LEN(fifoHeadString));
			MEMCPY(
				destAddr 	:= 	ADR(buffer) + SIZEOF(BYTE) * currentBufferPos,
				srcAddr 	:=	ADR(fifoHeadBytes),
				n			:=	fifoHeadLength);		
			currentBufferPos := currentBufferPos + fifoHeadLength; 	
		END_FOR
		state := STATE_APPEND_DATA_TO_FILE;
	END_IF
	lockFileWriteToForceRisingEdge := FALSE;
END_IF
	
// *** W R I T E   T O   F I L E ***
fbFileWrite(
	sNetId := NET_ID, 
	hFile := hFile, 
	pWriteBuff := ADR(buffer),
	cbWriteLen := currentBufferPos,
	bExecute := state = STATE_APPEND_DATA_TO_FILE, 
	tTimeout := TIMEOUT);	

IF state = STATE_APPEND_DATA_TO_FILE THEN
	lockFileWriteToForceRisingEdge := TRUE;		
	IF fbFileWrite.bError THEN
		state := STATE_CLOSE_FILE;
	ELSIF Fifo.nCount > 0 AND NOT fbFileWrite.bBusy THEN
		state := STATE_GET_STRING_FROM_FIFO; 
	ELSIF Fifo.nCount = 0 THEN
		state := STATE_CLOSE_FILE;
	END_IF
END_IF
		
// *** C L O S E   F I L E ***
fbFileClose(
	sNetId := NET_ID, hFile := hFile, 
	bExecute := (state = STATE_CLOSE_FILE), tTimeout := TIMEOUT);

IF state = STATE_CLOSE_FILE THEN
	IF NOT fbFileCLose.bBusy THEN state := STATE_IDLE; END_IF
END_IF

// Close file in case of error
IF fbFileOpen.bError THEN state := STATE_CLOSE_FILE; END_IF
IF fbFileWrite.bError THEN state := STATE_CLOSE_FILE; END_IF
IF NOT Fifo.bOk AND Fifo.nCount > 0 AND state <> STATE_IDLE THEN 
	state := STATE_CLOSE_FILE; 
END_IF

// Error handling
IF fbFileOpen.bError THEN
	Error.Active := TRUE;
	Error.Code := E_ErrorCode.OpeningFileFailed;
	Error.Info := CONCAT('Opening file failed. Error thrown by FB_FileOpen. Consult Beckhoff InfoSys. Internal Error: ', UDINT_TO_STRING(fbFileOpen.nErrId));
ELSIF fbFileWrite.bError THEN
	Error.Active := TRUE;
	Error.Code := E_ErrorCode.WritingToFileFailed;
	Error.Info := CONCAT('Writing to file failed. Error thrown by FB_FileWrite. Consult Beckhoff InfoSys. Internal Error: ', UDINT_TO_STRING(fbFileWrite.nErrId));
ELSIF fbFileClose.bError THEN
	Error.Active := TRUE;
	Error.Code := E_ErrorCode.ClosingFileFailed;
	Error.Info := CONCAT('Closing file failed. Error thrown by FB_FileClose. Consult Beckhoff InfoSys. Internal Error: ', UDINT_TO_STRING(fbFileClose.nErrId));
ELSIF NOT Fifo.bOk AND Fifo.nCount > 0 THEN
	Error.Active := TRUE;
	Error.Code := E_ErrorCode.FifoOverflow;
	Error.Info := 'FIFO overflow. Check if plc has enough free memory.';
ELSE
	Error.Active := FALSE;
	Error.Code := E_ErrorCode.None;
	Error.Info := '';
END_IF

// Set busy state
Busy := (state <> STATE_IDLE OR Fifo.nCount > 0);

(* Uncomment for cyclic logging of state machine, buffer usage & errors

ADSLOGSTR(ADSLOG_MSGTYPE_LOG, 
	CONCAT('****DynamicStringBuffer.state:', 
	CONCAT(UINT_TO_STRING(state),
	CONCAT(', DynamicStringBuffer.hFile:', UINT_TO_STRING(hFile)))), '');

ADSLOGSTR(ADSLOG_MSGTYPE_LOG, 
	CONCAT('****Fifo: used ', 
	CONCAT(UDINT_TO_STRING(Fifo.cbSize),
	CONCAT(' of ', UDINT_TO_STRING(Fifo.cbBuffer)))), '');
	
IF Error.Active THEN
	ADSLOGSTR(ADSLOG_MSGTYPE_LOG, 
		CONCAT('****DynamicStringBuffer.Error: ', Error.Info), 
		'');	
END_IF
*)]]></ST>
      </Implementation>
    </Method>
    <Method Name="PopHead" Id="{1c3e8de3-af72-4def-8aba-61974c7aa041}">
      <Declaration><![CDATA[METHOD PopHead : T_MAXSTRING
VAR_INPUT
END_VAR
VAR
	headString	:	T_MAXSTRING;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[Fifo.A_RemoveHead(getValue => headString);
PopHead := headString;]]></ST>
      </Implementation>
    </Method>
    <Method Name="ResizeFifoBufferIfNecessary" Id="{743741a9-70d0-433f-8900-11f7ea020fe9}">
      <Declaration><![CDATA[// Resizes the buffer for the FIFO if necessary
METHOD PRIVATE ResizeFifoBufferIfNecessary : BOOL
VAR_INPUT
END_VAR
VAR
	requiredSize : UDINT;
	newSize : DINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[requiredSize := Fifo.cbSize + MAX_STRING_LENGTH;

IF requiredSize > Fifo.cbBuffer THEN
	MemBuf.Resize(nSize := requiredSize*SIZEOF(BYTE), bPreserve:=TRUE, bReset:=TRUE);
	Fifo.pBuffer := MemBuf.pBuffer;
	Fifo.cbBuffer := requiredSize;
END_IF]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="DynamicStringBuffer">
      <LineId Id="9" Count="0" />
    </LineIds>
    <LineIds Name="DynamicStringBuffer.AddLine">
      <LineId Id="7" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="DynamicStringBuffer.AddString">
      <LineId Id="6" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="DynamicStringBuffer.AllocateBuffer">
      <LineId Id="6" Count="1" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="DynamicStringBuffer.Busy.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="DynamicStringBuffer.Busy.Set">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="DynamicStringBuffer.FB_exit">
      <LineId Id="6" Count="0" />
    </LineIds>
    <LineIds Name="DynamicStringBuffer.FlushCache">
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="DynamicStringBuffer.Init">
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="DynamicStringBuffer.PersistToFile">
      <LineId Id="695" Count="0" />
      <LineId Id="728" Count="1" />
      <LineId Id="859" Count="0" />
      <LineId Id="730" Count="32" />
      <LineId Id="764" Count="0" />
      <LineId Id="898" Count="0" />
      <LineId Id="765" Count="3" />
      <LineId Id="896" Count="0" />
      <LineId Id="769" Count="13" />
      <LineId Id="784" Count="23" />
      <LineId Id="899" Count="2" />
      <LineId Id="857" Count="0" />
      <LineId Id="810" Count="8" />
      <LineId Id="823" Count="33" />
      <LineId Id="340" Count="0" />
    </LineIds>
    <LineIds Name="DynamicStringBuffer.PopHead">
      <LineId Id="5" Count="0" />
      <LineId Id="9" Count="0" />
    </LineIds>
    <LineIds Name="DynamicStringBuffer.ResizeFifoBufferIfNecessary">
      <LineId Id="15" Count="0" />
      <LineId Id="18" Count="0" />
      <LineId Id="16" Count="0" />
      <LineId Id="20" Count="0" />
      <LineId Id="22" Count="1" />
      <LineId Id="13" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>